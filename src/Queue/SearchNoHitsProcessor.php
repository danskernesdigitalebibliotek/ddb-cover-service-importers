<?php

/**
 * @file
 */

namespace App\Queue;

use App\Entity\Search;
use App\Service\CoverStore\CoverStoreInterface;
use App\Utils\Message\ProcessMessage;
use App\Utils\Types\IdentifierType;
use Doctrine\DBAL\ConnectionException;
use Doctrine\ORM\EntityManagerInterface;
use Enqueue\Client\ProducerInterface;
use Enqueue\Client\TopicSubscriberInterface;
use Interop\Queue\PsrContext;
use Interop\Queue\PsrMessage;
use Interop\Queue\PsrProcessor;
use Karriere\JsonDecoder\JsonDecoder;
use Psr\Log\LoggerInterface;

/**
 * Class SearchNoHitsProcessor.
 */
class SearchNoHitsProcessor implements PsrProcessor, TopicSubscriberInterface
{
    private $em;
    private $coverStore;
    private $producer;
    private $statsLogger;

    const VENDOR = 'Unknown';

    // Magic datawell prefix for a basic PID.
    const BASIC_PID_PREFIX = '870970-basis:';

    /**
     * SearchNoHitsProcessor constructor.
     *
     * @param EntityManagerInterface $entityManager
     * @param CoverStoreInterface $coverStore
     * @param ProducerInterface $producer
     * @param LoggerInterface $statsLogger
     */
    public function __construct(EntityManagerInterface $entityManager, CoverStoreInterface $coverStore, ProducerInterface $producer, LoggerInterface $statsLogger)
    {
        $this->em = $entityManager;
        $this->coverStore = $coverStore;
        $this->producer = $producer;
        $this->statsLogger = $statsLogger;
    }

    /**
     * {@inheritdoc}
     */
    public function process(PsrMessage $message, PsrContext $session)
    {
        $jsonDecoder = new JsonDecoder(true);
        $processMessage = $jsonDecoder->decode($message->getBody(), ProcessMessage::class);
        $identifier = $processMessage->getIdentifier();

        // If it's a "katalog" identifier, we will try to check if a matching
        // "basic" identifier exits and create the mapping.
        if (strpos($identifier, '-katalog:')) {
            $parts = explode(':', $identifier);
            $basicPid = $this::BASIC_PID_PREFIX.end($parts);
            $repos = $this->em->getRepository(Search::class);

            try {
                // There may exists a race condition when multiple queues are
                // running. To ensure we don't insert duplicates we need to
                // wrap our search/update/insert in a transaction.
                $this->em->getConnection()->beginTransaction();

                try {
                    $search = $repos->findOneByisIdentifier($basicPid);

                    if (!empty($search)) {
                        $newSearch = new Search();
                        $newSearch->setIsType(IdentifierType::PID)
                            ->setIsIdentifier($identifier)
                            ->setSource($search->getSource())
                            ->setImageUrl($search->getImageUrl())
                            ->setImageFormat($search->getImageFormat())
                            ->setWidth($search->getWidth())
                            ->setHeight($search->getHeight())
                            ->setAutoGenerated($search->isAutoGenerated());
                        $this->em->persist($newSearch);

                        $this->em->flush();
                        $this->em->getConnection()->commit();

                        // Log that a new record was created.
                        $this->statsLogger->info('Katalog recorded have been generated', [
                            'service' => 'SearchNoHitsProcessor',
                            'message' => 'New katalog search record have been generated',
                            'identifier' => $identifier,
                            'source' => $basicPid,
                        ]);

                        return self::ACK;
                    }
                } catch (\Exception $exception) {
                    $this->em->getConnection()->rollBack();

                    $this->statsLogger->error('Database exception: '.get_class($exception), [
                        'service' => 'SearchNoHitsProcessor',
                        'message' => $exception->getMessage(),
                        'identifier' => $identifier,
                        'source' => $basicPid,
                    ]);
                }
            } catch (ConnectionException $exception) {
                $this->statsLogger->error('Database Connection Exception', [
                    'service' => 'SearchNoHitsProcessor',
                    'message' => $exception->getMessage(),
                    'identifier' => $identifier,
                    'source' => $basicPid,
                ]);
            }
        }

        // Log current not handled no hit.
        $this->statsLogger->info('No hit', [
            'service' => 'SearchNoHitsProcessor',
            'message' => 'No hit found and send to auto generate queue',
            'identifier' => $identifier,
        ]);

        // @TODO re-enable when we start to process auto-generate cover queue
        // Send to auto-generate cover queue.
        // $this->producer->sendEvent('CoverStoreAutoTopic', \json_encode($processMessage));

        return self::ACK;
    }

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedTopics()
    {
        return ['SearchNoHitsTopic' => [
                'processorName' => 'SearchNoHitsProcessor',
                'queueName' => 'BackgroundQueue',
            ],
        ];
    }
}
