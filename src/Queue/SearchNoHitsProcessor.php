<?php

/**
 * @file
 * Handle no-hits queue processing.
 */

namespace App\Queue;

use App\Entity\Search;
use App\Entity\Source;
use App\Service\CoverStore\CoverStoreInterface;
use App\Service\OpenPlatform\SearchService;
use App\Utils\Message\ProcessMessage;
use App\Utils\OpenPlatform\Material;
use App\Utils\Types\IdentifierType;
use App\Utils\Types\VendorState;
use Doctrine\DBAL\ConnectionException;
use Doctrine\ORM\EntityManagerInterface;
use Enqueue\Client\ProducerInterface;
use Enqueue\Client\TopicSubscriberInterface;
use Enqueue\Util\JSON;
use Interop\Queue\Context;
use Interop\Queue\Message;
use Interop\Queue\Processor;
use Karriere\JsonDecoder\JsonDecoder;
use Psr\Log\LoggerInterface;

/**
 * Class SearchNoHitsProcessor.
 */
class SearchNoHitsProcessor implements Processor, TopicSubscriberInterface
{
    private $em;
    private $coverStore;
    private $producer;
    private $statsLogger;
    private $searchService;

    const VENDOR = 'Unknown';

    // Magic datawell prefix for a basic PID.
    const BASIC_PID_PREFIX = '870970-basis:';

    /**
     * SearchNoHitsProcessor constructor.
     *
     * @param EntityManagerInterface $entityManager
     * @param CoverStoreInterface $coverStore
     * @param ProducerInterface $producer
     * @param LoggerInterface $statsLogger
     * @param SearchService $searchService
     */
    public function __construct(EntityManagerInterface $entityManager, CoverStoreInterface $coverStore, ProducerInterface $producer, LoggerInterface $statsLogger, SearchService $searchService)
    {
        $this->em = $entityManager;
        $this->coverStore = $coverStore;
        $this->producer = $producer;
        $this->statsLogger = $statsLogger;
        $this->searchService = $searchService;
    }

    /**
     * {@inheritdoc}
     */
    public function process(Message $message, Context $session)
    {
        $jsonDecoder = new JsonDecoder(true);
        /* @var ProcessMessage $processMessage */
        $processMessage = $jsonDecoder->decode($message->getBody(), ProcessMessage::class);
        $identifier = $processMessage->getIdentifier();

        // If it's a "katalog" identifier, we will try to check if a matching
        // "basic" identifier exits and create the mapping.
        if (strpos($identifier, '-katalog:')) {
            $parts = explode(':', $identifier);
            $basicPid = $this::BASIC_PID_PREFIX.end($parts);
            $searchRepos = $this->em->getRepository(Search::class);

            try {
                // There may exists a race condition when multiple queues are
                // running. To ensure we don't insert duplicates we need to
                // wrap our search/update/insert in a transaction.
                $this->em->getConnection()->beginTransaction();

                try {
                    $search = $searchRepos->findOneByisIdentifier($basicPid);

                    if (!empty($search)) {
                        $newSearch = new Search();
                        $newSearch->setIsType(IdentifierType::PID)
                            ->setIsIdentifier($identifier)
                            ->setSource($search->getSource())
                            ->setImageUrl($search->getImageUrl())
                            ->setImageFormat($search->getImageFormat())
                            ->setWidth($search->getWidth())
                            ->setHeight($search->getHeight())
                            ->setAutoGenerated($search->isAutoGenerated());
                        $this->em->persist($newSearch);

                        $this->em->flush();
                        $this->em->getConnection()->commit();

                        // Log that a new record was created.
                        $this->statsLogger->info('Katalog recorded have been generated', [
                            'service' => 'SearchNoHitsProcessor',
                            'message' => 'New katalog search record have been generated',
                            'identifier' => $identifier,
                            'source' => $basicPid,
                        ]);

                        return self::ACK;
                    }
                } catch (\Exception $exception) {
                    $this->em->getConnection()->rollBack();

                    $this->statsLogger->error('Database exception: '.get_class($exception), [
                        'service' => 'SearchNoHitsProcessor',
                        'message' => $exception->getMessage(),
                        'identifier' => $identifier,
                        'source' => $basicPid,
                    ]);
                }
            } catch (ConnectionException $exception) {
                $this->statsLogger->error('Database Connection Exception', [
                    'service' => 'SearchNoHitsProcessor',
                    'message' => $exception->getMessage(),
                    'identifier' => $identifier,
                    'source' => $basicPid,
                ]);
            }
        } else {
            // Try to search the data well and match source entity. This might work as there is an race between when
            // vendors have a given cover and when the material is indexed into the data-well.
            $type = $processMessage->getIdentifierType();
            $material = $this->searchService->search($identifier, $type);
            $sourceRepos = $this->em->getRepository(Source::class);

            foreach ($material->getIdentifiers() as $is) {
                $sources = $sourceRepos->findBy([
                    'matchId' => $is->getId(),
                    'matchType' => $is->getType(),
                ]);

                // Found matches in source table based on the data well search, so create jobs to re-index the source
                // entities. The re-indexing will take source rank etc. into account in the queue system.
                foreach ($sources as $source) {
                    $processMessage = new ProcessMessage();
                    $processMessage->setIdentifier($source->getMatchId())
                        ->setOperation(VendorState::UPDATE)
                        ->setIdentifierType($source->getMatchType())
                        ->setVendorId($source->getVendor()->getId())
                        ->setImageId($source->getImage()->getId())
                        ->setUseSearchCache(true);
                    $this->producer->sendEvent('SearchTopic', JSON::encode($processMessage));
                }
            }

            return self::ACK;
        }

        // Log current not handled no hit.
        $this->statsLogger->info('No hit', [
            'service' => 'SearchNoHitsProcessor',
            'message' => 'No hit found and send to auto generate queue',
            'identifier' => $identifier,
        ]);

        // @TODO re-enable when we start to process auto-generate cover queue
        // Send to auto-generate cover queue.
        // $this->producer->sendEvent('CoverStoreAutoTopic', \json_encode($processMessage));

        return self::ACK;
    }

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedTopics()
    {
        return ['SearchNoHitsTopic' => [
                'processorName' => 'SearchNoHitsProcessor',
                'queueName' => 'BackgroundQueue',
            ],
        ];
    }
}
