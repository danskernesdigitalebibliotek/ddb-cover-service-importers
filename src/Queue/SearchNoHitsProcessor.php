<?php

/**
 * @file
 * Handle no-hits queue processing.
 */

namespace App\Queue;

use App\Entity\Search;
use App\Entity\Source;
use App\Event\VendorEvent;
use App\Message\CoverStoreAutoMessage;
use App\Service\CoverStore\CoverStoreInterface;
use App\Service\OpenPlatform\SearchService;
use App\Service\VendorService\VendorImageValidatorService;
use App\Utils\CoverVendor\VendorImageItem;
use App\Utils\Message\ProcessMessage;
use App\Utils\OpenPlatform\Material;
use App\Utils\Types\IdentifierType;
use App\Utils\Types\VendorState;
use Doctrine\DBAL\ConnectionException;
use Doctrine\ORM\EntityManagerInterface;
use Enqueue\Client\TopicSubscriberInterface;
use GuzzleHttp\Exception\GuzzleException;
use Interop\Queue\Context;
use Interop\Queue\Message;
use Interop\Queue\Processor;
use Karriere\JsonDecoder\JsonDecoder;
use Psr\Log\LoggerInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Messenger\MessageBusInterface;

/**
 * Class SearchNoHitsProcessor.
 */
class SearchNoHitsProcessor implements Processor, TopicSubscriberInterface
{
    private $em;
    private $coverStore;
    private $bus;
    private $statsLogger;
    private $searchService;
    private $validatorService;
    private $dispatcher;

    const VENDOR = 'Unknown';

    /**
     * SearchNoHitsProcessor constructor.
     *
     * @param EntityManagerInterface $entityManager
     * @param CoverStoreInterface $coverStore
     * @param MessageBusInterface $bus
     * @param LoggerInterface $statsLogger
     * @param SearchService $searchService
     */
    public function __construct(EntityManagerInterface $entityManager, CoverStoreInterface $coverStore, MessageBusInterface $bus, LoggerInterface $statsLogger, SearchService $searchService, VendorImageValidatorService $validatorService, EventDispatcherInterface $eventDispatcher)
    {
        $this->em = $entityManager;
        $this->coverStore = $coverStore;
        $this->bus = $bus;
        $this->statsLogger = $statsLogger;
        $this->searchService = $searchService;
        $this->validatorService = $validatorService;
        $this->dispatcher = $eventDispatcher;
    }

    /**
     * {@inheritdoc}
     */
    public function process(Message $message, Context $session)
    {
        $jsonDecoder = new JsonDecoder(true);
        /* @var ProcessMessage $message */
        $message = $jsonDecoder->decode($message->getBody(), ProcessMessage::class);
        $identifier = $message->getIdentifier();

        // If it's a "katalog" identifier, we will try to check if a matching
        // "basic" identifier exits and create the mapping.
        if (strpos($identifier, '-katalog:')) {
            $searchRepos = $this->em->getRepository(Search::class);
            $basicPid = null;

            try {
                // Try to get basic pid.
                $basicPid = Material::translatePidToFaust($identifier);

                // There may exists a race condition when multiple queues are
                // running. To ensure we don't insert duplicates we need to
                // wrap our search/update/insert in a transaction.
                $this->em->getConnection()->beginTransaction();

                try {
                    $search = $searchRepos->findOneByisIdentifier($basicPid);

                    if (!empty($search)) {
                        $newSearch = new Search();
                        $newSearch->setIsType(IdentifierType::PID)
                            ->setIsIdentifier($identifier)
                            ->setSource($search->getSource())
                            ->setImageUrl($search->getImageUrl())
                            ->setImageFormat($search->getImageFormat())
                            ->setWidth($search->getWidth())
                            ->setHeight($search->getHeight())
                            ->setAutoGenerated($search->isAutoGenerated());
                        $this->em->persist($newSearch);

                        $this->em->flush();
                        $this->em->getConnection()->commit();

                        // Log that a new record was created.
                        $this->statsLogger->info('Katalog recorded have been generated', [
                            'service' => 'SearchNoHitsProcessor',
                            'message' => 'New katalog search record have been generated',
                            'identifier' => $identifier,
                            'source' => $basicPid,
                        ]);

                        return self::ACK;
                    }
                } catch (\Exception $exception) {
                    $this->em->getConnection()->rollBack();

                    $this->statsLogger->error('Database exception: '.get_class($exception), [
                        'service' => 'SearchNoHitsProcessor',
                        'message' => $exception->getMessage(),
                        'identifier' => $identifier,
                        'source' => $basicPid,
                    ]);
                }
            } catch (ConnectionException $exception) {
                $this->statsLogger->error('Database Connection Exception', [
                    'service' => 'SearchNoHitsProcessor',
                    'message' => $exception->getMessage(),
                    'identifier' => $identifier,
                    'source' => $basicPid ?: 'unknown',
                ]);
            }
        } else {
            // Try to search the data well and match source entity. This might work as there is an race between when
            // vendors have a given cover and when the material is indexed into the data-well.
            $type = $message->getIdentifierType();
            $material = $this->searchService->search($identifier, $type);
            $sourceRepos = $this->em->getRepository(Source::class);

            foreach ($material->getIdentifiers() as $is) {
                $source = $sourceRepos->findOneByVendorRank($is->getType(), $is->getId());

                // Found matches in source table based on the data well search, so create jobs to re-index the source
                // entities. Also check that the source record has an image from the vendor as not all do.
                if (false !== $source && !is_null($source->getImage())) {
                    $message = new ProcessMessage();
                    $message->setIdentifier($source->getMatchId())
                        ->setOperation(VendorState::UPDATE)
                        ->setIdentifierType($source->getMatchType())
                        ->setVendorId($source->getVendor()->getId())
                        ->setImageId($source->getImage()->getId())
                        ->setUseSearchCache(true);
                    $this->bus->dispatch($message);
                }

                // If the source image is null. It might have been made available since we asked the vendor for the
                // cover.
                if (is_null($source->getImage()) && !is_null($source->getOriginalFile())) {
                    $item = new VendorImageItem();
                    $item->setOriginalFile($source->getOriginalFile());
                    try {
                        $this->validatorService->validateRemoteImage($item);
                    } catch (GuzzleException $e) {
                        // Just remove this job from the queue, on fetch errors. This will ensure that the job is not
                        // re-queue in infinity loop.
                        return self::ACK;
                    }

                    // If the source image is null. It might have been made available since we asked the vendor for the
                    // cover.
                    if (is_null($source->getImage()) && !is_null($source->getOriginalFile())) {
                        $item = new VendorImageItem();
                        $item->setOriginalFile($source->getOriginalFile());
                        try {
                            $this->validatorService->validateRemoteImage($item);
                        } catch (GuzzleException $e) {
                            // Just remove this job from the queue, on fetch errors. This will ensure that the job is not
                            // re-queue in infinity loop.
                            return self::ACK;
                        }

                        if ($item->isFound()) {
                            $event = new VendorEvent(VendorState::UPDATE, [$source->getMatchId()], $source->getMatchType(), $source->getVendor()->getId());
                            $this->dispatcher->dispatch($event, $event::NAME);
                        }
                    }
                }
            }

            return self::ACK;
        }

        // Log current not handled no hit.
        $this->statsLogger->info('No hit', [
            'service' => 'SearchNoHitsProcessor',
            'message' => 'No hit found and send to auto generate queue',
            'identifier' => $identifier,
        ]);

        // @TODO re-enable when we start to process auto-generate cover queue
        // Send to auto-generate cover queue.
//        $coverStoreAutoMessage = new CoverStoreAutoMessage();
//        $coverStoreAutoMessage->setIdentifier($message->getIdentifier())
//            ->setIdentifierType($message->getIdentifierType())
//            ->setImageId($message->getImageId())
//            ->setOperation($message->getOperation())
//            ->setVendorId($message->getVendorId())
//            ->setUseSearchCache($message->useSearchCache());
//        $this->bus->dispatch($coverStoreAutoMessage);

        return self::ACK;
    }

    // phpcs:disable Symfony.Functions.ScopeOrder.Invalid

    /**
     * {@inheritdoc}
     */
    public static function getSubscribedTopics()
    {
        return ['SearchNoHitsTopic' => [
                'processorName' => 'SearchNoHitsProcessor',
                'queueName' => 'BackgroundQueue',
            ],
        ];
    }

    // phpcs:enable
}
